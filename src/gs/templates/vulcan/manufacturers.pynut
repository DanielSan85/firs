class VulcanManufacturers {
    // This class uses static methods to manage the singleton root table for manufacturers

    static function Init() {
        // manufacturers table should already be created by persistent storage init, if not it's an error
        if (!("manufacturers" in ::persistent_storage)) {
            throw "manufacturers table missing from persistent_storage";
        }

        Log.Info("--", Log.CLASS_VULCAN_MANUFACTURERS);
        Log.Info("VulcanManufacturers Init()", Log.CLASS_VULCAN_MANUFACTURERS);
        Log.Info("--", Log.CLASS_VULCAN_MANUFACTURERS);

        // Check if manufacturers are loaded from save, if not, create some for demonstration
        local required_categories = ["Steelmaker", "Automaker", "EquipmentManufacturer", "ChemicalsManufacturer", "BuildingMaterialsManufacturer"];
        local existing_categories = {};

        // Populate existing categories from persistent storage
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            Log.Info(manufacturer, Log.CLASS_VULCAN_MANUFACTURERS);
            existing_categories[manufacturer["category"]] <- true;
        }

        // Create missing manufacturer types
        foreach (category in required_categories) {
            if (!(category in existing_categories)) {
                local name = VulcanManufacturers.GenerateUniqueName(category);
                VulcanManufacturers.CreateManufacturer(category, name);
            }
        }

        VulcanManufacturers.AssignHQTowns();
        VulcanManufacturers.AssignOtherTowns();

        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            if (manufacturer["category"] == "Steelmaker") {
                TestSteelMaker.AssignIndustries(manufacturer_id, manufacturer);
            }
        }

        VulcanManufacturers.RunPeriodicProcessing("Init");
    }

    // Generate a unique name for a new manufacturer based on category
    static function GenerateUniqueName(category) {
        local base_names = {};
        base_names["Steelmaker"] <- ["Central Steel Inc.", "Steeltown Metals", "Ironclad Steel"];
        base_names["Automaker"] <- ["AutoWorks Ltd.", "Speedster Motors", "RoadKing Vehicles"];
        base_names["EquipmentManufacturer"] <- ["HeavyMach Corp.", "EquipCo", "Machinists Ltd."];
        base_names["ChemicalsManufacturer"] <- ["ChemMasters Inc.", "Industrial Chems", "Chemicals Co."];
        base_names["BuildingMaterialsManufacturer"] <- ["BuildRight Materials", "Concretia Supplies", "ConstructCo"];

        local used_names = {};
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            used_names[manufacturer["name"]] <- true;
        }

        local possible_names = base_names[category];
        if (possible_names == null) {
            throw "No possible names found for category: " + category;
        }

        foreach (name in possible_names) {
            if (!(name in used_names)) {
                return name;
            }
        }

        // If all possible names are used, generate a new unique name
        local suffix = 1;
        while (true) {
            local new_name = category + " " + suffix.tostring();
            if (!(new_name in used_names)) {
                return new_name;
            }
            suffix += 1;
        }
    }

    // Run periodic processing
    static function RunPeriodicProcessing(caller_type) {
        Log.Info("VulcanManufacturers RunPeriodicProcessing()", Log.CLASS_VULCAN_MANUFACTURERS);
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            Log.Info("Processing manufacturer manufacturer_id: " + manufacturer_id, Log.CLASS_VULCAN_MANUFACTURERS);
            VulcanManufacturers.ProcessMonthly(manufacturer);
        }
        /*
        if (caller_type != "Init") {
            Log.Info("...updating manufacturer story pages", Log.CLASS_VULCAN_MANUFACTURERS);
            VulcanManufacturers.UpdateManufacturerStoryPage();
        }
        */
    }

    // Create a new manufacturer
    static function CreateManufacturer(category, name) {
        local manufacturer = {};
        manufacturer["category"] <- category;
        manufacturer["name"] <- name;
        manufacturer["hq_town"] <- null;
        manufacturer["valid_towns"] <- [];

        ::persistent_storage["manufacturers"][name] <- manufacturer;
        Log.Info("Created manufacturer: " + name + " (" + category + ")", Log.CLASS_VULCAN_MANUFACTURERS);
    }

    static function AssignHQTowns() {
        local town_list = GSTownList();
        town_list.Valuate(GSBase.RandItem);
        town_list.Sort(GSList.SORT_BY_VALUE, GSList.SORT_ASCENDING);
        local town_list_towns = [];
        foreach (town, _ in town_list) {
            town_list_towns.append(town);
        }
        local manufacturers = ::persistent_storage["manufacturers"];

        foreach (manufacturer_name, manufacturer in manufacturers) {
            // note that this round-robins the randomised towns, so ideally we have no more than 1 manufacturer per town
            // but if manufacturers > towns, we don't deadlock
            local town_id = town_list_towns.pop();
            manufacturers[manufacturer_name]["hq_town"] <- town_id;
            town_list_towns.insert(0, town_id);
        }
    }

    // Example of a function to assign specific other towns
    static function AssignOtherTowns() {
        local town_list = GSTownList();
        local town_list_towns = [];
        // !! no filtering currently, just all towns
        foreach (town, _ in town_list) {
            town_list_towns.append(town);
        }

        local manufacturers = ::persistent_storage["manufacturers"];

        foreach (manufacturer_name, manufacturer in manufacturers) {
            manufacturers[manufacturer_name]["valid_towns"] <- town_list_towns;
        }
    }

    static function GetManufacturerByHQTown(town_id) {
        local manufacturers = ::persistent_storage["manufacturers"];
        foreach (name, manufacturer in manufacturers) {
            if (manufacturer["hq_town"] == town_id) {
                return manufacturer;
            }
        }
        return null;
    }

    // Generate a unique manufacturer_id for a new manufacturer
    static function GenerateUniqueID() {
        local max_id = 0;
        foreach (manufacturer_id, _ in ::persistent_storage["manufacturers"]) {
            if (manufacturer_id.tointeger() > max_id) max_id = manufacturer_id.tointeger();
        }
        return (max_id + 1).tostring();
    }

    /*
    function UpdateManfacturerStoryPage() {
        vulcan_manufacturers_story_pages[this.town].UpdatePage(this);
    }
    */

    // Process monthly updates
    static function ProcessMonthly(manufacturer) {
        Log.Info("Processing monthly for " + manufacturer["name"] + " (" + manufacturer["category"] + ")", Log.CLASS_VULCAN_MANUFACTURERS);
    }
}

// prototyping of industry behaviour

class TestSteelMaker {
    static function AssignIndustries(manufacturer_id, manufacturer) {
        Log.Info("Assigning industries for " + manufacturer["name"], Log.CLASS_VULCAN_MANUFACTURERS);
        local industry_list = GSIndustryList();
        foreach (industry, _ in industry_list) {
            foreach (industry_type in ["blast_furnace", "basic_oxygen_furnace"]) {
                if (GSIndustry.GetIndustryType(industry) == firs.industries[industry_type].global_id) {
                    Log.Info("Found " + GSIndustry.GetName(industry), Log.CLASS_VULCAN_MANUFACTURERS);
                    VulcanIndustryOwnership.AssignOwner(industry, "manufacturer", manufacturer_id);
                }
            }
        }
        Log.Info("Industries owned by " + manufacturer["name"] + ": " + Repr(VulcanIndustryOwnership.ListIndustries("manufacturer", manufacturer_id)));
    }

}
