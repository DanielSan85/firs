class VulcanManufacturers {
    // This class uses static methods to manage the singleton root table for manufacturers

    static function Init() {
        // manufacturers table should already be created by persistent storage init, if not it's an error
        if (!("manufacturers" in ::persistent_storage)) {
            throw "manufacturers table missing from persistent_storage";
        }

        Log.Info("--", Log.CLASS_VULCAN_MANUFACTURERS);
        Log.Info("VulcanManufacturers Init()", Log.CLASS_VULCAN_MANUFACTURERS);
        Log.Info("--", Log.CLASS_VULCAN_MANUFACTURERS);

        // Check if manufacturers are loaded from save, if not, create some for demonstration
        local required_categories = ["Steelmaker", "Automaker", "EquipmentManufacturer", "ChemicalsManufacturer", "BuildingMaterialsManufacturer"];
        local existing_categories = {};

        // Populate existing categories from persistent storage
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            Log.Info(manufacturer, Log.CLASS_VULCAN_MANUFACTURERS);
            existing_categories[manufacturer["category"]] <- true;
        }

        // Create missing manufacturer types
        foreach (category in required_categories) {
            if (!(category in existing_categories)) {
                // !! hax to create 2 for testing 'n' instances support
                local name = VulcanManufacturers.GenerateUniqueName(category);
                VulcanManufacturers.CreateManufacturer(category, name);
                local name = VulcanManufacturers.GenerateUniqueName(category);
                VulcanManufacturers.CreateManufacturer(category, name);
            }
        }

        // first find one industry for each manufacturer, in a priority order, then use that industry's town as HQ town for each manufacturer
        VulcanManufacturers.AssignFirstIndustries();
        VulcanManufacturers.AssignHQTowns();

        // !! the remaining industries need to round-robin between manufacturers, but we want to co-locate them near the HQ if possible, so eh
        // !! walk each manufacturer in turn, picking eligible industries from the industryy list until all eligible industries are assigned?
        // !! pre-assign a bunch of industries to 'self' ownership by type
        // CABBAGE

        VulcanManufacturers.RunPeriodicProcessing("Init");
    }

    // Generate a unique name for a new manufacturer based on category
    static function GenerateUniqueName(category) {
        local base_names = {};
        base_names["Steelmaker"] <- ["Central Steel Inc.", "Steeltown Metals", "Ironclad Steel"];
        base_names["Automaker"] <- ["AutoWorks Ltd.", "Speedster Motors", "RoadKing Vehicles"];
        base_names["EquipmentManufacturer"] <- ["HeavyMach Corp.", "EquipCo", "Machinists Ltd."];
        base_names["ChemicalsManufacturer"] <- ["ChemMasters Inc.", "Industrial Chems", "Chemicals Co."];
        base_names["BuildingMaterialsManufacturer"] <- ["BuildRight Materials", "Concretia Supplies", "ConstructCo"];

        local used_names = {};
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            used_names[manufacturer["name"]] <- true;
        }

        local possible_names = base_names[category];
        if (possible_names == null) {
            throw "No possible names found for category: " + category;
        }

        foreach (name in possible_names) {
            if (!(name in used_names)) {
                return name;
            }
        }

        // If all possible names are used, generate a new unique name
        local suffix = 1;
        while (true) {
            local new_name = category + " " + suffix.tostring();
            if (!(new_name in used_names)) {
                return new_name;
            }
            suffix += 1;
        }
    }

    // Run periodic processing
    static function RunPeriodicProcessing(caller_type) {
        Log.Info("VulcanManufacturers RunPeriodicProcessing()", Log.CLASS_VULCAN_MANUFACTURERS);
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            Log.Info("Processing manufacturer manufacturer_id: " + manufacturer_id, Log.CLASS_VULCAN_MANUFACTURERS);
            VulcanManufacturers.ProcessMonthly(manufacturer);
        }
        /*
        if (caller_type != "Init") {
            Log.Info("...updating manufacturer story pages", Log.CLASS_VULCAN_MANUFACTURERS);
            VulcanManufacturers.UpdateManufacturerStoryPage();
        }
        */
    }

    // Create a new manufacturer
    static function CreateManufacturer(category, name) {
        local manufacturer = {};
        manufacturer["category"] <- category;
        manufacturer["name"] <- name;
        manufacturer["hq_town"] <- null;
        manufacturer["valid_towns"] <- [];

        ::persistent_storage["manufacturers"][name] <- manufacturer;
        Log.Info("Created manufacturer: " + name + " (" + category + ")", Log.CLASS_VULCAN_MANUFACTURERS);
    }

    // Generate a unique manufacturer_id for a new manufacturer
    static function GenerateUniqueID() {
        local max_id = 0;
        foreach (manufacturer_id, _ in ::persistent_storage["manufacturers"]) {
            if (manufacturer_id.tointeger() > max_id) max_id = manufacturer_id.tointeger();
        }
        return (max_id + 1).tostring();
    }

    static function AssignFirstIndustries() {
        local industry_list = GSIndustryList();
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            TestManufacturerCabbage.AssignFirstIndustry(industry_list, manufacturer_id, manufacturer, TestManufacturerCabbage.GetKeystonesTemp(manufacturer));
        }
    }

    static function AssignHQTowns() {
        foreach (manufacturer_id, manufacturer in ::persistent_storage["manufacturers"]) {
            local manufacturer_industries = VulcanIndustryOwnership.ListIndustries("manufacturer", manufacturer_id);
            if (manufacturer_industries.len() > 0) {
                manufacturer["hq_town"] = GSTile.GetClosestTown(GSIndustry.GetLocation(manufacturer_industries[0]));
            }
            else {
                // if the manufacturer had *no* valid industries on the map, then assign a random town as HQ
                // we might try to build some industries near there later, or not(?)
                manufacturer["hq_town"] = AtlasRandomTown();
            }
        }
    }

    /*
    function UpdateManfacturerStoryPage() {
        vulcan_manufacturers_story_pages[this.town].UpdatePage(this);
    }
    */

    // Process monthly updates
    static function ProcessMonthly(manufacturer) {
        Log.Info("Processing monthly for " + manufacturer["name"] + " (" + manufacturer["category"] + ")", Log.CLASS_VULCAN_MANUFACTURERS);
    }
}

// prototyping of industry behaviour

class TestManufacturerCabbage {
    static function GetKeystonesTemp(manufacturer) {
        local keystones_temp = {
            Steelmaker = ["blast_furnace", "electric_arc_furnace"],
            Automaker = ["assembly_plant", "body_plant", "engine_plant"],
            EquipmentManufacturer = ["precision_parts_plant", "hardware_factory", "appliance_factory"],
            ChemicalsManufacturer = ["chlor_alkali_plant", "cryo_plant"],
            BuildingMaterialsManufacturer = ["concrete_plant", "pipework_fabricator"],
        };
        return keystones_temp[manufacturer["category"]];
    }

    static function AssignFirstIndustry(candidate_industry_list, manufacturer_id, manufacturer, target_industry_types) {
        Log.Info("Assigning industries for " + manufacturer["name"], Log.CLASS_VULCAN_MANUFACTURERS);
        foreach (industry, _ in candidate_industry_list) {
            if (VulcanIndustryOwnership.IsIndustryOwned(industry)) {
                continue;
            }
            // !!! this will always select keystones in order currently, that might be better randomised (or not)?
            foreach (industry_type in target_industry_types) {
                if (GSIndustry.GetIndustryType(industry) == firs.industries[industry_type].global_id) {
                    Log.Info("Found " + GSIndustry.GetName(industry), Log.CLASS_VULCAN_MANUFACTURERS);
                    VulcanIndustryOwnership.AssignOwner(industry, "manufacturer", manufacturer_id);
                    return true;
                }
            }
        }
        return false; // No industry assigned
    }
}
